

import React, { useState, useRef, useEffect, useCallback } from 'react';
import { 
  MousePointer2, 
  Cable, 
  Trash2, 
  RotateCw, 
  ToggleLeft,
  Zap,
  Circle
} from 'lucide-react';

// --- Types ---

type ComponentType = 
  | 'resistor' 
  | 'variable_resistor'
  | 'battery' 
  | 'capacitor' 
  | 'switch' 
  | 'bulb' 
  | 'led' 
  | 'diode'
  | 'ground' 
  | 'motor'
  | 'bell'
  | 'buzzer'
  | 'fuse'
  | 'voltmeter' 
  | 'ammeter' 
  | 'ac_source'
  | 'terminal'; // Added terminal

interface CircuitComponent {
  id: string;
  type: ComponentType;
  x: number;
  y: number;
  rotation: number; // 0, 90, 180, 270
  isOpen?: boolean; // For switches: true = OFF(Open), false = ON(Closed)
}

interface Wire {
  id: string;
  x1: number;
  y1: number;
  x2: number;
  y2: number;
}

type Tool = 'select' | 'wire';

// --- Constants ---
const GRID_SIZE = 20;
const SNAP_DISTANCE = 20;
const MIN_WIRE_LENGTH = 20;

// --- Helper Functions ---

const getTerminals = (comp: CircuitComponent) => {
  // Single terminal component
  if (comp.type === 'terminal') {
      return [{ x: comp.x, y: comp.y }];
  }

  // Two terminal components
  const r = comp.rotation * (Math.PI / 180);
  const cos = Math.cos(r);
  const sin = Math.sin(r);
  
  const t1 = {
    x: comp.x + (-30 * cos - 0 * sin),
    y: comp.y + (-30 * sin + 0 * cos)
  };
  
  const t2 = {
    x: comp.x + (30 * cos - 0 * sin),
    y: comp.y + (30 * sin + 0 * cos)
  };

  return [t1, t2];
};

// --- Simulation Logic (Union-Find & Graph Search) ---

class UnionFind {
  parent: number[];
  constructor(n: number) {
    this.parent = Array(n).fill(0).map((_, i) => i);
  }
  find(i: number): number {
    if (this.parent[i] === i) return i;
    return this.parent[i] = this.find(this.parent[i]);
  }
  union(i: number, j: number) {
    const rootI = this.find(i);
    const rootJ = this.find(j);
    if (rootI !== rootJ) {
      this.parent[rootI] = rootJ;
    }
  }
}

// --- Component Renderers (SVG) ---

const SymbolRenderer = ({ type, color = "currentColor", isOpen = true, isPowered = false }: { type: ComponentType, color?: string, isOpen?: boolean, isPowered?: boolean }) => {
  const strokeWidth = 2;
  const powerColor = "#fbbf24"; // Amber-400 for powered effect
  const powerGlow = isPowered ? "drop-shadow(0 0 4px #fbbf24)" : "";
  
  switch (type) {
    case 'terminal':
      return (
        <circle cx="30" cy="30" r="6" fill={color} stroke="none" />
      );
    case 'resistor':
      return (
        <g stroke={color} strokeWidth={strokeWidth} fill="none">
          <line x1="0" y1="30" x2="10" y2="30" />
          <rect x="10" y="20" width="40" height="20" fill={isPowered ? "#fef3c7" : "none"} />
          <line x1="50" y1="30" x2="60" y2="30" />
        </g>
      );
    case 'variable_resistor':
      return (
        <g stroke={color} strokeWidth={strokeWidth} fill="none">
          <line x1="0" y1="30" x2="10" y2="30" />
          <rect x="10" y="20" width="40" height="20" fill={isPowered ? "#fef3c7" : "none"} />
          <line x1="50" y1="30" x2="60" y2="30" />
          <line x1="20" y1="50" x2="40" y2="10" />
          <path d="M37,10 L40,10 L40,15" fill="none" /> 
        </g>
      );
    case 'battery':
      return (
        <g stroke={color} strokeWidth={strokeWidth} fill="none">
          <line x1="0" y1="30" x2="25" y2="30" />
          <line x1="25" y1="10" x2="25" y2="50" strokeWidth={3} />
          <line x1="35" y1="20" x2="35" y2="40" strokeWidth={3} />
          <line x1="35" y1="30" x2="60" y2="30" />
          <text x="12" y="15" fontSize="14" fill={color} stroke="none">+</text>
        </g>
      );
    case 'capacitor':
      return (
        <g stroke={color} strokeWidth={strokeWidth} fill="none">
          <line x1="0" y1="30" x2="25" y2="30" />
          <line x1="25" y1="15" x2="25" y2="45" />
          <line x1="35" y1="15" x2="35" y2="45" />
          <line x1="35" y1="30" x2="60" y2="30" />
        </g>
      );
    case 'switch':
      return (
        <g stroke={color} strokeWidth={strokeWidth} fill="none">
          <line x1="0" y1="30" x2="20" y2="30" />
          <circle cx="20" cy="30" r="2" fill={color} stroke="none"/>
          
          {isOpen ? (
            <line x1="20" y1="30" x2="38" y2="18" className="transition-all duration-200" /> 
          ) : (
            <line x1="20" y1="30" x2="40" y2="30" className="transition-all duration-200" />
          )}

          <circle cx="40" cy="30" r="2" fill={color} stroke="none"/>
          <line x1="40" y1="30" x2="60" y2="30" />
        </g>
      );
    case 'bulb':
      return (
        <g stroke={color} strokeWidth={strokeWidth} fill="none" style={{ filter: powerGlow }}>
          <line x1="0" y1="30" x2="15" y2="30" />
          <circle cx="30" cy="30" r="15" fill={isPowered ? powerColor : "none"} stroke={isPowered ? powerColor : color} fillOpacity={isPowered ? 0.6 : 0} />
          <line x1="20" y1="20" x2="40" y2="40" stroke={isPowered ? "#fff" : color} />
          <line x1="40" y1="20" x2="20" y2="40" stroke={isPowered ? "#fff" : color} />
          <line x1="45" y1="30" x2="60" y2="30" />
        </g>
      );
    case 'led':
      return (
        <g stroke={color} strokeWidth={strokeWidth} fill="none" style={{ filter: isPowered ? "drop-shadow(0 0 4px red)" : "" }}>
          <line x1="0" y1="30" x2="20" y2="30" />
          <path d="M20,20 L20,40 L40,30 Z" fill={isPowered ? "#ef4444" : "none"} stroke={isPowered ? "#ef4444" : color} />
          <line x1="40" y1="20" x2="40" y2="40" />
          <line x1="40" y1="30" x2="60" y2="30" />
          <path d="M42,15 L50,7 M48,15 L50,7 L50,11" strokeWidth={1} stroke={isPowered ? "#ef4444" : color} />
          <path d="M46,19 L54,11 M52,19 L54,11 L54,15" strokeWidth={1} stroke={isPowered ? "#ef4444" : color} />
        </g>
      );
    case 'diode':
      return (
        <g stroke={color} strokeWidth={strokeWidth} fill="none">
          <line x1="0" y1="30" x2="20" y2="30" />
          <path d="M20,20 L20,40 L40,30 Z" fill={color} />
          <line x1="40" y1="20" x2="40" y2="40" />
          <line x1="40" y1="30" x2="60" y2="30" />
        </g>
      );
    case 'ground':
      return (
        <g stroke={color} strokeWidth={strokeWidth} fill="none">
          <line x1="30" y1="0" x2="30" y2="30" />
          <line x1="15" y1="30" x2="45" y2="30" />
          <line x1="20" y1="36" x2="40" y2="36" />
          <line x1="25" y1="42" x2="35" y2="42" />
        </g>
      );
    case 'motor':
      return (
        <g stroke={color} strokeWidth={strokeWidth} fill="none">
           <line x1="0" y1="30" x2="10" y2="30" />
           <circle cx="30" cy="30" r="20" fill={isPowered ? "#e0f2fe" : "none"} />
           <g className={isPowered ? "animate-spin origin-center" : ""} style={{ transformOrigin: "30px 30px" }}>
             <text x="30" y="38" textAnchor="middle" fontSize="20" fontWeight="bold" fill={color} stroke="none">M</text>
             {isPowered && <path d="M30,15 L30,10" stroke={color} />}
           </g>
           <line x1="50" y1="30" x2="60" y2="30" />
        </g>
      );
    case 'bell':
        return (
          <g stroke={color} strokeWidth={strokeWidth} fill="none" className={isPowered ? "animate-pulse" : ""}>
            <line x1="0" y1="30" x2="13" y2="30" />
            <line x1="47" y1="30" x2="60" y2="30" />
            <path d="M13,30 A17,17 0 0,1 47,30" fill={isPowered ? "#fef3c7" : "none"} />
            <line x1="13" y1="30" x2="47" y2="30" />
            {isPowered && <path d="M15,20 L10,15 M45,20 L50,15" stroke={color} strokeWidth="1" />}
          </g>
        );
    case 'buzzer':
         return (
          <g stroke={color} strokeWidth={strokeWidth} fill="none" className={isPowered ? "animate-pulse" : ""}>
            <line x1="0" y1="30" x2="13" y2="30" />
            <line x1="47" y1="30" x2="60" y2="30" />
            <path d="M13,30 A17,17 0 0,0 47,30" fill={isPowered ? "#fef3c7" : "none"} />
            <line x1="13" y1="30" x2="47" y2="30" />
             <line x1="20" y1="30" x2="20" y2="40" />
             <line x1="40" y1="30" x2="40" y2="40" />
          </g>
         );
    case 'fuse':
        return (
          <g stroke={color} strokeWidth={strokeWidth} fill="none">
            <line x1="0" y1="30" x2="10" y2="30" />
            <rect x="10" y="20" width="40" height="20" />
            <line x1="10" y1="30" x2="50" y2="30" />
            <line x1="50" y1="30" x2="60" y2="30" />
          </g>
        );
    case 'voltmeter':
      return (
        <g stroke={color} strokeWidth={strokeWidth} fill="none">
          <line x1="0" y1="30" x2="15" y2="30" />
          <circle cx="30" cy="30" r="15" fill={isPowered ? "#e0f2fe" : "none"} />
          <text x="30" y="36" textAnchor="middle" fontSize="16" fontWeight="bold" fill={color} stroke="none">V</text>
          <line x1="45" y1="30" x2="60" y2="30" />
        </g>
      );
    case 'ammeter':
        return (
          <g stroke={color} strokeWidth={strokeWidth} fill="none">
            <line x1="0" y1="30" x2="15" y2="30" />
            <circle cx="30" cy="30" r="15" fill={isPowered ? "#e0f2fe" : "none"} />
            <text x="30" y="36" textAnchor="middle" fontSize="16" fontWeight="bold" fill={color} stroke="none">A</text>
            <line x1="45" y1="30" x2="60" y2="30" />
          </g>
        );
    case 'ac_source':
        return (
            <g stroke={color} strokeWidth={strokeWidth} fill="none">
              <line x1="0" y1="30" x2="15" y2="30" />
              <circle cx="30" cy="30" r="15" stroke={isPowered ? "#fbbf24" : color} strokeWidth={isPowered ? 3 : 2} />
              <path d="M20,30 Q25,22 30,30 T40,30" fill="none" />
              <line x1="45" y1="30" x2="60" y2="30" />
            </g>
          );
    default:
      return null;
  }
};

const COMPONENT_LABELS: Record<ComponentType, string> = {
  terminal: '端子',
  resistor: '抵抗',
  variable_resistor: '可変抵抗',
  battery: '電池',
  capacitor: 'コンデンサ',
  switch: 'スイッチ',
  bulb: '電球',
  led: 'LED',
  diode: 'ダイオード',
  ground: 'アース',
  motor: '電動機',
  bell: 'ベル',
  buzzer: 'ブザー',
  fuse: 'ヒューズ',
  voltmeter: '電圧計',
  ammeter: '電流計',
  ac_source: '交流電源',
};


export default function CircuitApp() {
  const [components, setComponents] = useState<CircuitComponent[]>([]);
  const [wires, setWires] = useState<Wire[]>([]);
  const [selectedId, setSelectedId] = useState<string | null>(null);
  const [tool, setTool] = useState<Tool>('select');
  const [isDragging, setIsDragging] = useState(false);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const dragStartPos = useRef<{ x: number, y: number } | null>(null);
  
  // Wire creation state
  const [drawingWire, setDrawingWire] = useState<{ x: number; y: number } | null>(null);
  const [wireStart, setWireStart] = useState<{ x: number; y: number } | null>(null);
  
  // Sticky wires state
  const [attachedWires, setAttachedWires] = useState<{ wireId: string, end: '1'|'2', offsetX: number, offsetY: number }[]>([]);

  // Simulation State
  const [poweredState, setPoweredState] = useState<{ components: Set<string>, wires: Set<string> }>({ components: new Set(), wires: new Set() });

  const svgRef = useRef<SVGSVGElement>(null);

  // --- Simulation Logic ---

  const analyzeCircuit = useCallback(() => {
    // 1. Map all terminal coordinates to Node IDs using Union-Find
    const points: { x: number, y: number, id: string }[] = [];
    
    // Add component terminals
    components.forEach(c => {
      const terminals = getTerminals(c);
      terminals.forEach((t, i) => {
          points.push({ x: t.x, y: t.y, id: `${c.id}_t${i}` });
      });
    });

    // Add wire ends
    wires.forEach(w => {
      points.push({ x: w.x1, y: w.y1, id: `${w.id}_w1` });
      points.push({ x: w.x2, y: w.y2, id: `${w.id}_w2` });
    });

    // Create Union-Find structure
    const uf = new UnionFind(points.length);
    
    // Union overlapping points
    for (let i = 0; i < points.length; i++) {
      for (let j = i + 1; j < points.length; j++) {
        const dx = Math.abs(points[i].x - points[j].x);
        const dy = Math.abs(points[i].y - points[j].y);
        
        // Wire connection check - wires connect their own ends electrically
        if (points[i].id.split('_')[0] === points[j].id.split('_')[0] && points[i].id.includes('w') && points[j].id.includes('w')) {
             uf.union(i, j);
        }
        // Spatial connection check (overlap)
        else if (dx < 5 && dy < 5) { 
          uf.union(i, j);
        }
      }
    }

    // Map each point ID to a representative Node ID
    const pointToNode = new Map<string, number>();
    points.forEach((p, i) => {
      pointToNode.set(p.id, uf.find(i));
    });

    // 2. Build Adjacency List
    const adj = new Map<number, { node: number, compId: string }[]>();
    
    const addEdge = (u: number, v: number, compId: string) => {
      if (!adj.has(u)) adj.set(u, []);
      if (!adj.has(v)) adj.set(v, []);
      adj.get(u)?.push({ node: v, compId });
      adj.get(v)?.push({ node: u, compId });
    };

    components.forEach(c => {
        if (c.type === 'switch' && c.isOpen) return;
        if (c.type === 'terminal') return; // Terminal just connects nodes via spatial union, no internal edge

        const terminals = getTerminals(c);
        if (terminals.length === 2) {
             const u = pointToNode.get(`${c.id}_t0`);
             const v = pointToNode.get(`${c.id}_t1`);
             if (u !== undefined && v !== undefined && u !== v) {
                addEdge(u, v, c.id);
             }
        }
    });

    // 3. Find powered paths from sources
    const poweredComps = new Set<string>();
    const sources = components.filter(c => c.type === 'battery' || c.type === 'ac_source');

    sources.forEach(source => {
        const startNode = pointToNode.get(`${source.id}_t0`);
        const endNode = pointToNode.get(`${source.id}_t1`);

        if (startNode === undefined || endNode === undefined) return;

        // DFS to find cycle/path back to source
        const stack: { node: number, path: string[], visitedNodes: Set<number> }[] = [
            { node: startNode, path: [], visitedNodes: new Set([startNode]) }
        ];

        while (stack.length > 0) {
            const { node, path, visitedNodes } = stack.pop()!;

            if (node === endNode) {
                path.forEach(id => poweredComps.add(id));
                poweredComps.add(source.id); 
                continue; 
            }

            const neighbors = adj.get(node) || [];
            for (const neighbor of neighbors) {
                if (neighbor.compId === source.id) continue;

                if (!visitedNodes.has(neighbor.node)) {
                    const newVisited = new Set(visitedNodes);
                    newVisited.add(neighbor.node);
                    stack.push({
                        node: neighbor.node,
                        path: [...path, neighbor.compId],
                        visitedNodes: newVisited
                    });
                }
            }
        }
    });

    // 4. Identify powered wires
    const poweredWires = new Set<string>();
    const activeNodes = new Set<number>();
    components.forEach(c => {
        if (poweredComps.has(c.id)) {
            const terminals = getTerminals(c);
            terminals.forEach((_, i) => {
                const n = pointToNode.get(`${c.id}_t${i}`);
                if (n !== undefined) activeNodes.add(n);
            });
        }
    });

    wires.forEach(w => {
        const n1 = pointToNode.get(`${w.id}_w1`);
        if (activeNodes.has(n1!)) {
            poweredWires.add(w.id);
        }
    });

    setPoweredState({ components: poweredComps, wires: poweredWires });

  }, [components, wires]);

  useEffect(() => {
    analyzeCircuit();
  }, [components, wires, analyzeCircuit]);


  // --- Logic ---

  const getSnappedPosition = useCallback((x: number, y: number, currentComponents: CircuitComponent[]) => {
    let closestTerminal = null;
    let minDistance = SNAP_DISTANCE;

    for (const comp of currentComponents) {
      const terminals = getTerminals(comp);
      for (const t of terminals) {
        const dx = t.x - x;
        const dy = t.y - y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < minDistance) {
          minDistance = dist;
          closestTerminal = t;
        }
      }
    }

    if (closestTerminal) {
      return { x: closestTerminal.x, y: closestTerminal.y, snappedToTerminal: true };
    }

    return { 
      x: Math.round(x / GRID_SIZE) * GRID_SIZE, 
      y: Math.round(y / GRID_SIZE) * GRID_SIZE,
      snappedToTerminal: false
    };
  }, []);

  const addComponent = useCallback((type: ComponentType) => {
    // Avoid spawning on top of existing things
    let startX = 200;
    let startY = 200;
    let found = false;
    let attempts = 0;

    while (!found && attempts < 100) {
        // Check collision with components
        const compCollision = components.some(c => Math.abs(c.x - startX) < 40 && Math.abs(c.y - startY) < 40);
        
        // Check collision with wire ends (to avoid accidental auto-connect)
        // We check a radius around spawn point
        const wireCollision = wires.some(w => 
            (Math.abs(w.x1 - startX) < 40 && Math.abs(w.y1 - startY) < 40) ||
            (Math.abs(w.x2 - startX) < 40 && Math.abs(w.y2 - startY) < 40)
        );

        if (!compCollision && !wireCollision) {
            found = true;
        } else {
            startX += 20;
            startY += 20;
            if (startX > 600) { startX = 100; startY += 60; }
            attempts++;
        }
    }

    const newComp: CircuitComponent = {
      id: Math.random().toString(36).substr(2, 9),
      type,
      x: startX,
      y: startY,
      rotation: 0,
      isOpen: type === 'switch' ? true : undefined,
    };
    setComponents(prev => [...prev, newComp]);
    setSelectedId(newComp.id);
    setTool('select');
  }, [components, wires]);

  const updateComponent = useCallback((id: string, updates: Partial<CircuitComponent>) => {
    setComponents(prev => prev.map(c => c.id === id ? { ...c, ...updates } : c));
  }, []);

  const deleteSelected = useCallback(() => {
    setSelectedId(currentId => {
      if (!currentId) return null;
      
      setComponents(prev => prev.filter(c => c.id !== currentId));
      if (currentId.startsWith('wire-')) {
          setWires(prev => prev.filter(w => w.id !== currentId));
      }
      return null;
    });
  }, []);

  const rotateSelected = useCallback(() => {
    setSelectedId(currentId => {
        if (!currentId || currentId.startsWith('wire-')) return currentId;
        
        setComponents(prev => {
            const comp = prev.find(c => c.id === currentId);
            if (!comp) return prev;
            
            const oldTerminals = getTerminals(comp);
            const newRotation = (comp.rotation + 90) % 360;
            const newComp = { ...comp, rotation: newRotation };
            const newTerminals = getTerminals(newComp);

            // Rotate wires attached to terminals
            setWires(prevWires => prevWires.map(w => {
                let nw = { ...w };
                oldTerminals.forEach((ot, index) => {
                    // Check if wire connected to this terminal
                    if (Math.abs(w.x1 - ot.x) < 1 && Math.abs(w.y1 - ot.y) < 1) {
                        if (newTerminals[index]) {
                            nw.x1 = newTerminals[index].x;
                            nw.y1 = newTerminals[index].y;
                        }
                    }
                    if (Math.abs(w.x2 - ot.x) < 1 && Math.abs(w.y2 - ot.y) < 1) {
                        if (newTerminals[index]) {
                            nw.x2 = newTerminals[index].x;
                            nw.y2 = newTerminals[index].y;
                        }
                    }
                });
                return nw;
            }));

            return prev.map(c => c.id === currentId ? newComp : c);
        });
        return currentId;
    });
  }, []);

  const toggleSwitch = useCallback((targetId?: string) => {
    const idToToggle = targetId || selectedId;
    if (!idToToggle) return;
    
    setComponents(prev => prev.map(c => {
      if (c.id === idToToggle && c.type === 'switch') {
        return { ...c, isOpen: !c.isOpen };
      }
      return c;
    }));
  }, [selectedId]);

  const clearCanvas = useCallback(() => {
    if(window.confirm("キャンバスをクリアしますか？")) {
        setComponents([]);
        setWires([]);
        setSelectedId(null);
    }
  }, []);

  // --- Event Handlers ---

  const getSvgPoint = useCallback((e: React.PointerEvent) => {
    if (!svgRef.current) return { x: 0, y: 0 };
    const svg = svgRef.current;
    const pt = svg.createSVGPoint();
    
    pt.x = e.clientX;
    pt.y = e.clientY;
    
    const svgP = pt.matrixTransform(svg.getScreenCTM()?.inverse());
    return { x: svgP.x, y: svgP.y };
  }, []);

  const handlePointerDown = (e: React.PointerEvent) => {
    e.preventDefault();
    const { x, y } = getSvgPoint(e);
    
    if (tool === 'wire') {
      (e.target as Element).setPointerCapture(e.pointerId);
      const snapped = getSnappedPosition(x, y, components);
      
      if (!snapped.snappedToTerminal) {
          return;
      }

      setWireStart(snapped);
      setDrawingWire(snapped);
      setSelectedId(null); 
    } else {
        if (e.target === svgRef.current) {
            setSelectedId(null);
        }
    }
  };

  const handlePointerMove = (e: React.PointerEvent) => {
    e.preventDefault();
    const { x, y } = getSvgPoint(e);
    
    if (tool === 'wire' && wireStart) {
      const snapped = getSnappedPosition(x, y, components);
      setDrawingWire(snapped);
    } else if (isDragging && selectedId && !selectedId.startsWith('wire-')) {
        // Move component
        const newX = Math.round((x - dragOffset.x) / GRID_SIZE) * GRID_SIZE;
        const newY = Math.round((y - dragOffset.y) / GRID_SIZE) * GRID_SIZE;
        
        updateComponent(selectedId, { x: newX, y: newY });

        // Move attached wires
        if (attachedWires.length > 0) {
           setWires(prev => prev.map(w => {
               const attachment = attachedWires.find(aw => aw.wireId === w.id);
               if (attachment) {
                   const comp = components.find(c => c.id === selectedId);
                   if (!comp) return w;
                   
                   const dx = newX - comp.x;
                   const dy = newY - comp.y;
                   
                   return {
                       ...w,
                       x1: attachment.end === '1' ? w.x1 + dx : w.x1,
                       y1: attachment.end === '1' ? w.y1 + dy : w.y1,
                       x2: attachment.end === '2' ? w.x2 + dx : w.x2,
                       y2: attachment.end === '2' ? w.y2 + dy : w.y2,
                   };
               }
               return w;
           }));
        }
    }
  };

  const handlePointerUp = (e: React.PointerEvent) => {
    e.preventDefault();
    
    if (tool === 'wire' && wireStart && drawingWire) {
      const dx = drawingWire.x - wireStart.x;
      const dy = drawingWire.y - wireStart.y;
      const length = Math.sqrt(dx*dx + dy*dy);

      const endSnap = getSnappedPosition(drawingWire.x, drawingWire.y, components);

      if (length > MIN_WIRE_LENGTH && endSnap.snappedToTerminal) {
        const newWire: Wire = {
          id: `wire-${Math.random().toString(36).substr(2, 9)}`,
          x1: wireStart.x,
          y1: wireStart.y,
          x2: drawingWire.x,
          y2: drawingWire.y,
        };
        setWires(prev => [...prev, newWire]);
      }

      setWireStart(null);
      setDrawingWire(null);
      
      if (e.target instanceof Element && e.target.hasPointerCapture(e.pointerId)) {
          e.target.releasePointerCapture(e.pointerId);
      }
    }
    
    setIsDragging(false);
    setAttachedWires([]);
  };

  const handleComponentPointerDown = (e: React.PointerEvent, id: string, cx: number, cy: number) => {
    if (tool === 'wire') return; 
    
    e.stopPropagation(); 
    e.preventDefault();
    (e.target as Element).setPointerCapture(e.pointerId);
    
    setSelectedId(id);
    setIsDragging(true);
    
    const { x, y } = getSvgPoint(e);
    setDragOffset({ x: x - cx, y: y - cy });
    dragStartPos.current = { x, y };

    const comp = components.find(c => c.id === id);
    if (comp) {
        const terminals = getTerminals(comp);
        const attached = [];
        wires.forEach(w => {
            if (terminals.some(t => Math.abs(t.x - w.x1) < 1 && Math.abs(t.y - w.y1) < 1)) {
                attached.push({ wireId: w.id, end: '1' as const, offsetX: 0, offsetY: 0 });
            }
            if (terminals.some(t => Math.abs(t.x - w.x2) < 1 && Math.abs(t.y - w.y2) < 1)) {
                attached.push({ wireId: w.id, end: '2' as const, offsetX: 0, offsetY: 0 });
            }
        });
        setAttachedWires(attached);
    }
  };
  
  const handleComponentPointerUp = (e: React.PointerEvent, id: string) => {
      e.stopPropagation();
      if (dragStartPos.current) {
          const { x, y } = getSvgPoint(e);
          const dist = Math.hypot(x - dragStartPos.current.x, y - dragStartPos.current.y);
          if (dist < 10) { 
              const comp = components.find(c => c.id === id);
              if (comp?.type === 'switch') {
                  toggleSwitch(id);
              }
          }
      }
      dragStartPos.current = null;

      if (e.target instanceof Element && e.target.hasPointerCapture(e.pointerId)) {
        e.target.releasePointerCapture(e.pointerId);
      }
      setIsDragging(false);
      setAttachedWires([]);
  }

  const handleWirePointerDown = (e: React.PointerEvent, id: string) => {
      if (tool === 'select') {
          e.stopPropagation();
          e.preventDefault();
          setSelectedId(id);
      }
  };

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (['INPUT', 'TEXTAREA'].includes((e.target as HTMLElement).tagName)) return;

      if (e.key === 'Delete' || e.key === 'Backspace') {
        deleteSelected();
      }
      if (e.key === 'r' || e.key === 'R') {
        rotateSelected();
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [deleteSelected, rotateSelected]);

  const selectedComponent = components.find(c => c.id === selectedId);

  return (
    <div className="flex flex-col h-screen bg-gray-50 text-gray-800 font-sans select-none touch-none">
      <header className="bg-white border-b border-gray-200 px-4 py-3 flex items-center justify-between shadow-sm z-10 shrink-0">
        <div />

        <div className="flex items-center space-x-4 bg-gray-100 rounded-lg p-1">
          <button
            onClick={() => setTool('select')}
            className={`p-2 rounded-md transition-colors flex items-center space-x-2 ${
              tool === 'select' ? 'bg-white shadow text-blue-600' : 'text-gray-600 hover:bg-gray-200'
            }`}
            title="選択ツール (移動・回転・削除)"
          >
            <MousePointer2 size={18} />
            <span className="text-sm font-medium">選択・編集</span>
          </button>
          <button
            onClick={() => setTool('wire')}
            className={`p-2 rounded-md transition-colors flex items-center space-x-2 ${
              tool === 'wire' ? 'bg-white shadow text-blue-600' : 'text-gray-600 hover:bg-gray-200'
            }`}
            title="配線ツール (ドラッグして線を引く)"
          >
            <Cable size={18} />
            <span className="text-sm font-medium">配線</span>
          </button>
        </div>

        <div className="flex items-center space-x-2">
            <button
                onClick={(e) => { e.stopPropagation(); toggleSwitch(); }}
                onPointerDown={(e) => e.stopPropagation()}
                disabled={!selectedId || selectedComponent?.type !== 'switch'}
                className="p-2 text-blue-600 hover:bg-blue-50 rounded-md disabled:opacity-30 disabled:cursor-not-allowed active:bg-blue-100"
                title="スイッチ切り替え"
            >
                <ToggleLeft size={20} />
            </button>

            <button 
                onClick={(e) => { e.stopPropagation(); rotateSelected(); }} 
                onPointerDown={(e) => e.stopPropagation()} 
                disabled={!selectedId || selectedId.startsWith('wire')}
                className="p-2 text-gray-600 hover:bg-gray-100 rounded-md disabled:opacity-30 disabled:cursor-not-allowed active:bg-gray-200"
                title="回転 (R)"
            >
                <RotateCw size={20} />
            </button>
            <button 
                onClick={(e) => { e.stopPropagation(); deleteSelected(); }} 
                onPointerDown={(e) => e.stopPropagation()} 
                disabled={!selectedId}
                className="p-2 text-red-600 hover:bg-red-50 rounded-md disabled:opacity-30 disabled:cursor-not-allowed active:bg-red-100"
                title="削除 (Del)"
            >
                <Trash2 size={20} />
            </button>
             <div className="w-px h-6 bg-gray-300 mx-2"></div>
            <button 
                onClick={(e) => { e.stopPropagation(); clearCanvas(); }} 
                onPointerDown={(e) => e.stopPropagation()} 
                className="p-2 text-gray-600 hover:bg-gray-100 rounded-md active:bg-gray-200"
                title="全てクリア"
            >
                <Trash2 size={20} className="text-gray-400" />
            </button>
        </div>
      </header>

      <div className="flex flex-1 overflow-hidden">
        <aside className="w-64 bg-white border-r border-gray-200 flex flex-col shadow-[4px_0_24px_rgba(0,0,0,0.02)] z-10 overflow-hidden shrink-0">
          <div className="p-4 border-b border-gray-100">
            <h2 className="text-sm font-bold text-gray-500 uppercase tracking-wider mb-3">部品パレット</h2>
          </div>
          
          <div className="flex-1 overflow-y-auto p-4 scrollbar-thin">
            <div className="grid grid-cols-2 gap-3">
              {(Object.keys(COMPONENT_LABELS) as ComponentType[]).map((type) => (
                <button
                  key={type}
                  onClick={() => addComponent(type)}
                  onPointerDown={(e) => e.stopPropagation()} 
                  className="flex flex-col items-center justify-center p-3 border border-gray-200 rounded-lg hover:border-blue-400 hover:bg-blue-50 transition-all group touch-manipulation active:scale-95"
                >
                  <div className="w-12 h-10 flex items-center justify-center text-gray-700 group-hover:text-blue-600 mb-2 pointer-events-none">
                    <svg width="40" height="40" viewBox="0 0 60 60">
                         <SymbolRenderer type={type} isOpen={type === 'switch' ? true : undefined} isPowered={true} />
                    </svg>
                  </div>
                  <span className="text-xs font-medium text-gray-600 group-hover:text-blue-700">
                    {COMPONENT_LABELS[type]}
                  </span>
                </button>
              ))}
            </div>
          </div>
          
          <div className="p-4 bg-gray-50 border-t border-gray-200">
             <div className="text-xs text-gray-500 space-y-1">
                 <p>• <kbd className="bg-white border rounded px-1">Tap</kbd> 選択 / スイッチ切替</p>
                 <p>• <kbd className="bg-white border rounded px-1">Drag</kbd> 移動/配線</p>
             </div>
          </div>
        </aside>

        <main className="flex-1 relative bg-gray-50 overflow-hidden cursor-crosshair">
            <div 
                className="absolute inset-0 pointer-events-none opacity-20"
                style={{
                    backgroundImage: `radial-gradient(circle, #000 1px, transparent 1px)`,
                    backgroundSize: `${GRID_SIZE}px ${GRID_SIZE}px`
                }}
            />

            <svg
                ref={svgRef}
                className="w-full h-full touch-none"
                onPointerDown={handlePointerDown}
                onPointerMove={handlePointerMove}
                onPointerUp={handlePointerUp}
                onPointerLeave={handlePointerUp}
            >
                {wires.map(wire => (
                    <g 
                        key={wire.id} 
                        onPointerDown={(e) => handleWirePointerDown(e, wire.id)}
                        className="cursor-pointer group"
                    >
                        <line
                            x1={wire.x1}
                            y1={wire.y1}
                            x2={wire.x2}
                            y2={wire.y2}
                            stroke="transparent"
                            strokeWidth={30}
                            strokeLinecap="round"
                        />
                        <line
                            x1={wire.x1}
                            y1={wire.y1}
                            x2={wire.x2}
                            y2={wire.y2}
                            stroke={selectedId === wire.id ? "#3b82f6" : (poweredState.wires.has(wire.id) ? "#f59e0b" : "#333")}
                            strokeWidth={selectedId === wire.id ? 4 : (poweredState.wires.has(wire.id) ? 3 : 2)}
                            className="group-hover:stroke-blue-400 transition-colors pointer-events-none"
                            style={{ filter: poweredState.wires.has(wire.id) ? "drop-shadow(0 0 2px #f59e0b)" : "none" }}
                        />
                    </g>
                ))}

                {drawingWire && wireStart && (
                   <g>
                    <line
                        x1={wireStart.x}
                        y1={wireStart.y}
                        x2={drawingWire.x}
                        y2={drawingWire.y}
                        stroke={getSnappedPosition(drawingWire.x, drawingWire.y, components).snappedToTerminal ? "#3b82f6" : "#ef4444"} 
                        strokeWidth="2"
                        strokeDasharray="5,5"
                        opacity="0.6"
                        className="pointer-events-none"
                    />
                     <circle cx={drawingWire.x} cy={drawingWire.y} r="5" fill={getSnappedPosition(drawingWire.x, drawingWire.y, components).snappedToTerminal ? "#3b82f6" : "#ef4444"} opacity="0.5" />
                   </g>
                )}

                {components.map((comp) => (
                    <g
                        key={comp.id}
                        transform={`translate(${comp.x - 30}, ${comp.y - 30}) rotate(${comp.rotation}, 30, 30)`}
                        onPointerDown={(e) => handleComponentPointerDown(e, comp.id, comp.x, comp.y)}
                        onPointerUp={(e) => handleComponentPointerUp(e, comp.id)}
                        className={`cursor-move ${tool === 'wire' ? 'pointer-events-none' : ''}`}
                        style={{ cursor: tool === 'wire' ? 'crosshair' : (comp.type === 'switch' ? 'pointer' : 'move') }}
                    >
                        {selectedId === comp.id && (
                            <rect
                                x="-5"
                                y="-5"
                                width="70"
                                height="70"
                                fill="none"
                                stroke="#3b82f6"
                                strokeWidth="1.5"
                                rx="4"
                                strokeDasharray="4 2"
                            />
                        )}
                        
                        <rect x="0" y="0" width="60" height="60" fill="transparent" />

                        <SymbolRenderer 
                            type={comp.type} 
                            color={selectedId === comp.id ? "#1d4ed8" : "#000"} 
                            isOpen={comp.isOpen}
                            isPowered={poweredState.components.has(comp.id)}
                        />
                        
                        {tool === 'wire' && (
                           <>
                             {getTerminals(comp).map((t, i) => {
                                 // Transform back to local coordinates for rendering
                                 // Or simpler: just render circles at local spots
                                 // For 2-terminal components: (0, 30) and (60, 30) if local center is (30,30) and unrotated width is 60.
                                 // Wait, SymbolRenderer draws inside 60x60 box.
                                 // Terminals are logically at local (0,30) and (60,30) relative to SVG origin (0,0)?
                                 // No, SymbolRenderer is centered.
                                 // Let's rely on standard positions.
                                 return null; // visual cue handled by snap indicator
                             })}
                             {/* Visual hint for terminals */}
                             {comp.type === 'terminal' ? (
                                 <circle cx="30" cy="30" r="8" fill="#ef4444" opacity="0.3" className="animate-pulse" />
                             ) : (
                                 <>
                                    <circle cx="0" cy="30" r="6" fill="#ef4444" opacity="0.3" className="animate-pulse" />
                                    <circle cx="60" cy="30" r="6" fill="#ef4444" opacity="0.3" className="animate-pulse" />
                                 </>
                             )}
                           </>
                        )}
                    </g>
                ))}
            </svg>
            
            <div className="absolute bottom-4 right-4 bg-white/80 backdrop-blur px-3 py-1.5 rounded-full border border-gray-200 text-xs text-gray-500 shadow-sm pointer-events-none">
                部品数: {components.length} | 配線数: {wires.length}
            </div>
            {selectedId && selectedId.startsWith('wire-') && (
                 <div className="absolute bottom-16 right-4 bg-red-100 text-red-600 px-3 py-1 rounded-md text-sm animate-bounce shadow-sm pointer-events-none">
                    配線を選択中: 削除ボタンで消去
                 </div>
            )}
            {poweredState.components.size > 0 && (
                <div className="absolute top-20 right-4 bg-amber-100 text-amber-700 px-3 py-1 rounded-md text-sm font-bold shadow-sm pointer-events-none flex items-center animate-pulse">
                    <Zap size={14} className="mr-1" /> 通電中
                </div>
            )}
        </main>
      </div>
    </div>
  );
}